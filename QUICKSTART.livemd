# Quick Start: Raw PCM Audio Streaming for VAD

This is exactly what you need - streaming raw PCM audio chunks with `Kino.listen/2` for Voice Activity Detection (VAD) in Elixir.

## Your Use Case

```elixir
Mix.install([
  {:kino_live_audio, path: "#{__DIR__}"}
])
```

## Setup for VAD

```elixir
sample_rate = 16_000

live_audio = KinoLiveAudio.new(
  chunk_size: 30,      # 30ms chunks
  unit: :ms,
  sample_rate: sample_rate
)
```

## Access Raw PCM Samples

```elixir
live_audio
|> Kino.listen(fn chunk ->
  # chunk is raw PCM data (Float32 samples in binary format)
  # Each sample is 4 bytes (32-bit float), value between -1.0 and 1.0

  IO.puts("Received PCM chunk: #{byte_size(chunk)} bytes")

  # Parse the binary into Float32 samples
  samples = for <<sample::float-32-little <- chunk>>, do: sample
  IO.puts("  Samples: #{length(samples)}")
  IO.puts("  First sample: #{List.first(samples)}")

  # You can write to a file
  File.write!(Path.join(__DIR__, "files/output.log"), inspect(chunk), [:append])

  # Or process for VAD
  # calculate_rms(samples)
  # detect_voice(samples)
end)

IO.puts("‚úÖ Listener attached! Start recording to receive PCM chunks.")
```

Click "Start Recording" and speak into your microphone. You'll see raw PCM chunks arriving!

## Simple VAD Implementation

```elixir
defmodule SimpleVAD do
  def calculate_rms(pcm_binary) do
    samples = for <<sample::float-32-little <- pcm_binary>>, do: sample
    sum_squares = Enum.reduce(samples, 0.0, fn s, acc -> acc + s * s end)
    :math.sqrt(sum_squares / length(samples))
  end

  def voice_active?(pcm_binary, threshold \\ 0.02) do
    calculate_rms(pcm_binary) > threshold
  end
end

# Use it
recorder = KinoLiveAudio.new(
  chunk_size: 30,
  unit: :ms,
  sample_rate: 16_000
)

recorder
|> Kino.listen(fn chunk ->
  if SimpleVAD.voice_active?(chunk) do
    IO.puts("üé§ Voice detected!")
    # Send to speech recognition, save, etc.
  else
    IO.puts("üîá Silence")
  end
end)

recorder
```

## What You Get

Each chunk is **raw PCM audio** in Float32 format:
- **Format**: pcm_f32le (32-bit float, little-endian)
- **Channels**: Mono (1 channel)
- **Sample values**: -1.0 to 1.0 (normalized)
- **No compression**: Direct access to waveform samples

At 16kHz with 30ms chunks:
- 30ms = 480 samples
- 480 samples √ó 4 bytes = 1920 bytes per chunk
- ~33 chunks per second

## Why Raw PCM?

Unlike compressed formats (MP3, WebM), you get:
- ‚úÖ **Direct sample access** - Calculate RMS, zero-crossing rate, spectral features
- ‚úÖ **Real-time processing** - No decoding latency
- ‚úÖ **Predictable chunks** - Exact sample count every time
- ‚úÖ **Perfect for VAD** - Analyze audio properties immediately
- ‚úÖ **DSP ready** - Apply filters, transformations, feature extraction

## Real-time VAD Monitor

```elixir
vad_recorder = KinoLiveAudio.new(
  chunk_size: 50,
  unit: :ms,
  sample_rate: 16_000
)

# Create a frame for live updates
frame = Kino.Frame.new() |> Kino.render()

vad_recorder
|> Kino.listen(fn chunk ->
  rms = SimpleVAD.calculate_rms(chunk)
  active = SimpleVAD.voice_active?(chunk)

  Kino.Frame.render(frame, Kino.Markdown.new("""
  ## üéôÔ∏è Voice Activity Detection

  **Status:** #{if active, do: "üü¢ VOICE DETECTED", else: "‚ö´ SILENCE"}

  **RMS Energy:** #{Float.round(rms, 4)}

  **Visual:** #{String.duplicate("‚ñà", trunc(rms * 100))}
  """))
end)

vad_recorder
```

## Converting PCM to WAV

If you need to save as WAV:

```elixir
defmodule WAVConverter do
  def pcm_to_wav(pcm_f32_data, sample_rate) do
    # Convert Float32 to Int16
    samples = for <<sample::float-32-little <- pcm_f32_data>> do
      int_sample = trunc(sample * 32767)
      max(min(int_sample, 32767), -32768)
    end

    pcm_int16 = for sample <- samples, into: <<>> do
      <<sample::little-signed-16>>
    end

    data_size = byte_size(pcm_int16)

    <<
      "RIFF", data_size + 36::little-32, "WAVE",
      "fmt ", 16::little-32, 1::little-16, 1::little-16,
      sample_rate::little-32, sample_rate * 2::little-32,
      2::little-16, 16::little-16,
      "data", data_size::little-32,
      pcm_int16::binary
    >>
  end
end

# Use it
pcm_data = KinoLiveAudio.read(vad_recorder)
if pcm_data do
  wav_data = WAVConverter.pcm_to_wav(pcm_data, 16_000)
  File.write!("recording.wav", wav_data)
end
```

## Perfect for Your VAD Processing!

You now have direct access to raw audio samples in Elixir, perfect for:
- Voice Activity Detection
- Speech recognition preprocessing
- Audio feature extraction
- Real-time audio analysis
- Custom DSP algorithms
